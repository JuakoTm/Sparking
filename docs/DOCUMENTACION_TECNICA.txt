================================================================================
S-PARKING - SISTEMA DE GESTION INTELIGENTE DE ESTACIONAMIENTOS
DOCUMENTACION TECNICA COMPLETA - PARTE 1
ARQUITECTURA, FRONTEND Y FUNCIONALIDADES
================================================================================

FECHA: Diciembre 2025
VERSION: Final
AUTOR: Equipo S-Parking


================================================================================
1. RESUMEN EJECUTIVO
================================================================================

S-Parking es una plataforma web integral para la gestion de estacionamientos
inteligentes. El sistema combina hardware IoT (sensores ESP32 + VL53L0X) con
una aplicacion web moderna que permite monitorear en tiempo real el estado de
cada puesto de estacionamiento, gestionar zonas, analizar patrones de ocupacion
y ofrecer un sistema de reservas para usuarios.

OBJETIVO PRINCIPAL:
Digitalizar y optimizar la gestion de estacionamientos mediante tecnologia IoT
y computacion en la nube, reduciendo tiempos de busqueda de espacios y 
proporcionando datos accionables para administradores.

USUARIOS OBJETIVO:
- Estacionamientos universitarios
- Estacionamientos corporativos
- Estacionamientos publicos
- Centros comerciales
- Edificios residenciales


================================================================================
2. ARQUITECTURA DEL SISTEMA
================================================================================

2.1 ARQUITECTURA GENERAL
-------------------------

El sistema S-Parking sigue una arquitectura de tres capas:

CAPA 1 - HARDWARE (IoT)
- Sensores ESP32 con VL53L0X ToF
- Conexion WiFi
- LED RGB para senalizacion visual
- Deteccion de presencia de vehiculos

CAPA 2 - BACKEND (Cloud)
- Google Cloud Platform (GCP)
- Cloud Run (contenedores serverless Node.js)
- Firestore (base de datos NoSQL)
- Firebase Hosting (archivos estaticos)

CAPA 3 - FRONTEND (Web)
- Aplicacion web SPA (Single Page Application)
- JavaScript vanilla (sin frameworks pesados)
- Google Maps API para visualizacion
- Chart.js para graficos
- Tailwind CSS para estilos


2.2 FLUJO DE DATOS
------------------

1. Sensor ESP32 detecta cambio de estado (libre/ocupado)
2. ESP32 envia POST request a Cloud Run endpoint
3. Cloud Run actualiza documento en Firestore
4. Dashboard web consulta estado cada 20 segundos
5. Interfaz actualiza mapa y estadisticas
6. Sistema genera snapshots horarios para historicos


2.3 COMPONENTES PRINCIPALES
----------------------------

HARDWARE:
- ESP32 DevKit (microcontrolador WiFi)
- VL53L0X Time-of-Flight sensor (medicion distancia laser)
- LED RGB WS2812B (senalizacion visual)
- Fuente alimentacion 5V

BACKEND:
- API REST en Node.js 20
- Firestore colecciones: parking_spots, zones, hourly_snapshots
- Cloud Run servicios: ingest-data, get-status, manage-zones
- Firebase Authentication (Email/Password)

FRONTEND:
- HTML5, CSS3, JavaScript ES6+
- Modulos: auth, api, map, ui, utils
- Google Maps JavaScript API
- Chart.js 4.x
- Tailwind CSS via CDN


================================================================================
3. ESTRUCTURA DEL PROYECTO
================================================================================

3.1 ESTRUCTURA DE DIRECTORIOS
------------------------------

S-Parking Web Final/
│
├── index.html                      # Pagina de aterrizaje
├── login.html                      # Pagina de autenticacion
├── dashboard.html                  # Dashboard principal
├── docs.html                       # Documentacion tecnica
│
├── css/
│   └── styles.css                  # Estilos personalizados
│
├── js/
│   ├── main.js                     # Logica principal dashboard
│   │
│   ├── auth/
│   │   └── auth.js                 # Autenticacion Firebase
│   │
│   ├── api/
│   │   ├── parking.js              # API estado puestos
│   │   ├── zones.js                # API gestion zonas
│   │   └── history.js              # API datos historicos
│   │
│   ├── map/
│   │   ├── core.js                 # Inicializacion Google Maps
│   │   ├── markers.js              # Gestion marcadores
│   │   ├── admin.js                # Herramientas admin mapa
│   │   └── builder.js              # Modo construccion puestos
│   │
│   ├── ui/
│   │   ├── sidebar.js              # Barra lateral puestos
│   │   ├── modals.js               # Ventanas modales
│   │   ├── charts.js               # Graficos Chart.js
│   │   ├── toasts.js               # Notificaciones
│   │   └── sounds.js               # Efectos sonido
│   │
│   ├── utils/
│   │   ├── helpers.js              # Funciones auxiliares
│   │   ├── formatters.js           # Formato fechas/textos
│   │   ├── validators.js           # Validacion datos
│   │   └── logger.js               # Sistema logging
│   │
│   └── config/
│       └── config.js               # Configuracion centralizada
│
├── gcp-functions/                  # Cloud Functions
│   ├── create-parking-spot_function-source/
│   ├── delete-parking-spot_function-source/
│   ├── get-zones_function-source/
│   ├── manage-zones_function-source/
│   └── [otras funciones]/
│
└── [archivos configuracion]
    ├── .firebaserc
    ├── firebase.json
    └── firestore.rules


3.2 ARCHIVOS HTML PRINCIPALES
------------------------------

index.html:
- Pagina de aterrizaje con informacion del producto
- Secciones: Hero, Solucion, Analytics, ROI, FAQ, Contacto
- Diseno responsive con Tailwind CSS
- Links a dashboard, login y documentacion

login.html:
- Formulario autenticacion con Firebase
- Login con email/password
- Validacion de campos
- Redireccion a dashboard tras login exitoso

dashboard.html:
- Interfaz principal del sistema
- Mapa Google Maps con marcadores de puestos
- Sidebar con lista de puestos filtrable
- Contadores de ocupacion en tiempo real
- Modal de analisis con graficos
- Panel de administrador (crear/editar/eliminar puestos)
- Sistema de reservas

docs.html:
- Documentacion tecnica del proyecto
- Secciones: Resumen, Arquitectura, Stack, API, Hardware, etc.
- Tabla de contenidos navegable
- Tablas de especificaciones
- Bloques de codigo con syntax highlighting


================================================================================
4. CONFIGURACION (config.js)
================================================================================

4.1 ENDPOINTS API
-----------------

CONFIG.API_BASE = 'https://cloud-run-url.run.app'

Endpoints principales:
- PARKING_STATUS_URL: obtener estado de todos los puestos
- CREATE_SPOT_URL: crear nuevo puesto (admin)
- DELETE_SPOT_URL: eliminar puesto (admin)
- UPDATE_SPOT_URL: actualizar puesto (admin)
- ZONES_URL: obtener listado de zonas
- MANAGE_ZONES_URL: crear/editar/eliminar zonas (admin)
- RESERVATION_API_URL: reservar puesto
- RELEASE_API_URL: liberar puesto reservado
- HISTORY_API_URL: obtener datos historicos


4.2 GOOGLE MAPS
---------------

CONFIG.GOOGLE_MAPS_API_KEY = 'AIzaSy...'
CONFIG.MAP_ID = 'id-del-mapa-estilizado'

Configuracion mapa:
- Centro inicial: latitud/longitud del estacionamiento
- Zoom inicial: 20 (vista detallada)
- Tipo: roadmap
- Controles: sin zoom buttons, con fullscreen
- Gestion de gestos: greedy (scroll con un dedo en movil)


4.3 FIREBASE
------------

CONFIG.FIREBASE_CONFIG:
- apiKey: clave API Firebase
- authDomain: dominio autenticacion
- projectId: ID proyecto GCP
- storageBucket: bucket almacenamiento
- messagingSenderId: ID mensajeria
- appId: ID aplicacion


4.4 PERFORMANCE
---------------

CONFIG.PERFORMANCE:
- POLLING_INTERVAL: 20000 (20 segundos)
- HISTORY_REFRESH: 600000 (10 minutos)
- TIMER_UPDATE: 5000 (5 segundos)
- CACHE_PARKING_STATUS: 15000 (15 segundos)
- CACHE_ZONES: 300000 (5 minutos)
- CACHE_HISTORY: 600000 (10 minutos)
- DEBOUNCE_SEARCH: 400 (400 milisegundos)
- LAZY_RENDER: true


4.5 RECOMENDACIONES
-------------------

CONFIG.RECOMMENDATIONS:
- CRITICAL_OCCUPANCY_PCT: 80 (umbral saturacion)
- CRITICAL_TIME_HIGH: 30 (porcentaje critico alto)
- CRITICAL_TIME_MED: 10 (porcentaje critico medio)
- VARIABILITY_HIGH: 30 (coeficiente variacion alto)
- VARIABILITY_MED: 15 (coeficiente variacion medio)
- AVAIL_GOOD: 40 (disponibilidad buena)
- AVAIL_LOW: 20 (disponibilidad baja)
- PEAK_THRESHOLD: 70 (umbral pico)
- MORNING_RANGE: [7, 10] (horario matutino)
- EVENING_RANGE: [17, 20] (horario vespertino)
- MAX_ITEMS: 4 (maximo recomendaciones)


================================================================================
5. AUTENTICACION (auth.js)
================================================================================

5.1 SISTEMA DE AUTENTICACION
-----------------------------

Implementacion:
- Firebase Authentication con Email/Password
- Persistencia de sesion en localStorage
- Proteccion de rutas (redireccion si no autenticado)

Funciones principales:
- initAuth(): inicializa Firebase Auth
- loginUser(email, password): inicio sesion
- logoutUser(): cierre sesion
- onAuthStateChanged(): listener cambios autenticacion
- getCurrentUser(): obtener usuario actual


5.2 FLUJO DE AUTENTICACION
---------------------------

1. Usuario accede a dashboard.html
2. Sistema verifica si hay usuario autenticado
3. Si no hay usuario, redirige a login.html
4. Usuario ingresa credenciales
5. Firebase valida credenciales
6. Si validas, redirige a dashboard.html
7. Dashboard carga datos del usuario


5.3 ROLES Y PERMISOS
--------------------

Por implementar:
- Usuario regular: consulta estado, reserva puestos
- Administrador: CRUD completo de puestos y zonas

Actualmente:
- Todos los usuarios autenticados tienen acceso completo
- Toggle "Modo Admin" en dashboard para funciones avanzadas


================================================================================
6. API PARKING (api/parking.js)
================================================================================

6.1 FUNCIONES PRINCIPALES
--------------------------

fetchParkingStatus():
- Obtiene estado actual de todos los puestos
- Implementa cache en memoria (15 segundos TTL)
- Retorna array de objetos spot
- Fallback a localStorage si falla

createSpot(data):
- Crea nuevo puesto (admin)
- Parametros: id, lat, lng, desc, zone_id, status
- Invalida cache tras creacion
- Fallback local si falla API

updateSpot(spotId, data):
- Actualiza informacion de puesto
- Parametros: desc, zone_id, lat, lng, status
- Invalida cache tras actualizacion

deleteSpot(spotId):
- Elimina puesto del sistema
- Invalida cache tras eliminacion
- Actualiza localStorage

reserveSpot(spotId, licensePlate, durationMinutes):
- Reserva puesto para usuario
- Invalida cache para reflejar cambio inmediato

releaseSpot(spotId):
- Libera puesto reservado
- Invalida cache

bulkAssignSpots(zoneId, spotIds):
- Asigna multiples puestos a una zona
- Itera sobre array de IDs

invalidateParkingCache():
- Limpia cache de estado de puestos
- Se llama automaticamente tras operaciones de escritura


6.2 ESTRUCTURA OBJETO SPOT
---------------------------

{
  id: "A1",                    // Identificador unico
  lat: -33.4569,               // Latitud
  lng: -70.6483,               // Longitud
  status: 1,                   // 0=ocupado, 1=libre, 2=reservado
  desc: "Piso 1 - Entrada",    // Descripcion
  zone_id: "zona-norte",       // ID zona asignada
  sensor_status: 0,            // Estado sensor hardware
  updated_at: "2025-12-02...", // Ultima actualizacion
  created_at: "2025-11-01...", // Fecha creacion
  reservation: {               // Datos reserva (si status=2)
    user_id: "user@email.com",
    expires_at: "2025-12-02...",
    license_plate: "AB1234"
  }
}


6.3 CACHE INTELIGENTE
---------------------

Mecanismo:
- Variable global cachedStatus y cacheStatusTimestamp
- Al llamar fetchParkingStatus(), verifica timestamp
- Si cache valido (< 15s), retorna datos cacheados
- Si cache expirado, hace fetch real y actualiza cache
- Cache se invalida automaticamente tras operaciones CRUD

Beneficios:
- Reduce requests a Cloud Run en 60-75%
- Mejora tiempo respuesta UI
- Mantiene datos frescos tras operaciones criticas


================================================================================
7. API ZONES (api/zones.js)
================================================================================

7.1 FUNCIONES PRINCIPALES
--------------------------

fetchZones():
- Obtiene listado completo de zonas
- Implementa cache en memoria (5 minutos TTL)
- Retorna array de objetos zone
- Fallback a localStorage si falla

manageZone(action, zoneData):
- Funcion unificada para CRUD zonas
- Parametro action: 'create', 'update', 'delete'
- zoneData: objeto con campos de zona
- Invalida cache tras operacion

invalidateZonesCache():
- Limpia cache de zonas
- Llamado automaticamente tras manageZone


7.2 ESTRUCTURA OBJETO ZONE
---------------------------

{
  id: "zona-norte",           // ID unico (generado o custom)
  name: "Zona Norte",         // Nombre descriptivo
  desc: "Piso 1 entrada",     // Descripcion opcional
  order: 1,                   // Orden visualizacion
  color: "#3b82f6",           // Color hexadecimal
  created_at: "2025-11-01..." // Fecha creacion
}


7.3 OPERACIONES ZONA
--------------------

Crear zona:
- action: 'create'
- zoneData: { name, desc, color, order }
- Backend genera ID unico

Actualizar zona:
- action: 'update'
- zoneData: { id, name, desc, color, order }
- Actualiza campos especificados

Eliminar zona:
- action: 'delete'
- zoneData: { id }
- No elimina puestos asociados (quedan sin zona)


================================================================================
8. API HISTORY (api/history.js)
================================================================================

8.1 FUNCIONES PRINCIPALES
--------------------------

fetchOccupancyHistory(daysBack):
- Obtiene datos historicos de ocupacion
- Parametro daysBack: cantidad dias hacia atras (default 2)
- Retorna objeto con samples y zones_summary
- Cache en memoria (10 minutos TTL)

fetchDailyHistory(date):
- Obtiene datos de un dia especifico
- Parametro date: objeto Date JavaScript
- Retorna datos horarios del dia seleccionado


8.2 ESTRUCTURA RESPUESTA HISTORY
---------------------------------

{
  success: true,
  samples: [
    {
      ts: "2025-12-02T10:00:00Z",   // Timestamp
      global_occupancy_pct: 65.5,   // Ocupacion global
      zones_summary: [               // Datos por zona
        {
          id: "zona-norte",
          name: "Zona Norte",
          occupancy_pct: 70.2,
          free: 5,
          occupied: 15
        }
      ]
    }
  ],
  period: {
    start: "2025-11-30T00:00:00Z",
    end: "2025-12-02T23:59:59Z"
  }
}


8.3 PROCESAMIENTO DATOS
------------------------

extractZoneOccupancy(samples, zoneId):
- Extrae datos especificos de una zona
- Calcula min, max, avg, variabilidad
- Retorna objeto con metricas agregadas

Metricas calculadas:
- Ocupacion promedio
- Ocupacion minima
- Ocupacion maxima
- Desviacion estandar
- Coeficiente variacion
- Horarios pico


================================================================================
9. GOOGLE MAPS (map/core.js)
================================================================================

9.1 INICIALIZACION MAPA
------------------------

initMap():
- Funcion principal inicializacion
- Carga libreria Google Maps via importLibrary()
- Configura opciones mapa
- Establece centro y zoom
- Desactiva controles innecesarios
- Configura gestion gestos

Opciones mapa:
- mapId: mapa estilizado custom
- center: coordenadas iniciales
- zoom: 20 (muy cercano)
- zoomControl: false (sin botones zoom)
- fullscreenControl: true
- streetViewControl: false
- mapTypeControl: false
- gestureHandling: 'greedy' (scroll con 1 dedo movil)


9.2 GESTION ESTADO
------------------

mapState objeto global:
- map: instancia google.maps.Map
- google: referencia a libreria google.maps
- isReady: boolean estado inicializacion

getMapState():
- Retorna estado actual del mapa
- Util para otros modulos verificar disponibilidad


9.3 COMPATIBILIDAD
------------------

Sistema detecta version API Maps:
- Intenta metodo moderno (importLibrary)
- Fallback a version clasica si falla
- Logs informativos para debugging


================================================================================
10. MARCADORES MAPA (map/markers.js)
================================================================================

10.1 GESTION MARCADORES
------------------------

createOrUpdateMarkers(spots, map, google, onClick):
- Crea o actualiza marcadores en mapa
- spots: array objetos spot
- map: instancia Google Maps
- google: libreria google.maps
- onClick: callback click en marcador

Comportamiento:
- Reutiliza marcadores existentes
- Crea nuevos solo si necesario
- Actualiza posicion y color segun estado
- Agrega listener click


10.2 COLORES MARCADORES
------------------------

Estado -> Color:
- Libre (1): verde (#10b981)
- Ocupado (0): rojo (#ef4444)
- Reservado (2): ambar (#f59e0b)

Marcador seleccionado:
- Borde adicional para destacar
- Animacion bounce temporal


10.3 OPTIMIZACION VISTA
------------------------

updateClusterView(zoom):
- Ajusta tamaño marcadores segun zoom
- Zoom bajo: marcadores pequeños
- Zoom alto: marcadores grandes
- Transicion suave entre tamaños

Escalas por zoom:
- Zoom 15: scale 0.3
- Zoom 17: scale 0.6
- Zoom 19+: scale 1.0


10.4 FUNCIONES AUXILIARES
--------------------------

highlightMarker(spotId):
- Destaca marcador temporalmente
- Animacion bounce 3 segundos
- Usado al hacer click en sidebar

clearAllMarkers():
- Remueve todos los marcadores del mapa
- Libera memoria
- Resetea coleccion interna


================================================================================
11. HERRAMIENTAS ADMIN MAPA (map/admin.js)
================================================================================

11.1 MODO ADMINISTRADOR
-----------------------

enableAdminMode(map, google):
- Activa herramientas admin en mapa
- Click en mapa para crear puestos
- Arrastra marcadores para reposicionar
- Smart Ruler: muestra distancia a puesto cercano

disableAdminMode():
- Desactiva herramientas admin
- Remueve listeners click mapa
- Deshabilita arrastre marcadores


11.2 CREACION PUESTOS
---------------------

Flujo crear puesto:
1. Admin activa modo admin
2. Hace click en ubicacion deseada en mapa
3. Sistema crea pin temporal en esa posicion
4. Abre modal con formulario
5. Admin ingresa ID, descripcion, zona
6. Sistema crea puesto via API
7. Actualiza mapa con nuevo marcador

createNewSpotPreview(latLng):
- Crea pin temporal preview
- Color distintivo (azul)
- No interactivo hasta confirmar


11.3 EDICION PUESTOS
--------------------

makeMarkersDraggable():
- Habilita arrastre en marcadores existentes
- Solo funciona en modo admin activo

onMarkerDragEnd(marker, spotId):
- Callback al soltar marcador
- Obtiene nuevas coordenadas
- Actualiza puesto via API
- Muestra toast confirmacion


11.4 SMART RULER
----------------

Funcionalidad:
- Al crear nuevo puesto, calcula distancia a puesto mas cercano
- Muestra linea visual en mapa
- Ayuda a mantener espaciado consistente
- Util para no crear puestos duplicados

Implementacion:
- Itera sobre puestos existentes
- Calcula distancia haversine
- Dibuja polyline al mas cercano
- Muestra distancia en metros


================================================================================
12. MODO CONSTRUCCION (map/builder.js)
================================================================================

12.1 BUILDER MODE
-----------------

Herramienta especializada para:
- Crear multiples puestos rapidamente
- Definir grid o patron de puestos
- Configuracion masiva de zona

enableBuilderMode(map, google, options):
- Activa modo construccion
- options: { pattern, spacing, zoneId, prefix }
- Deshabilita interacciones normales

Patrones disponibles:
- Grid rectangular: filas y columnas
- Linea: puestos en fila
- Manual: click individual


12.2 CONFIGURACION GRID
------------------------

Parametros:
- rows: numero filas
- cols: numero columnas
- spacing: metros entre puestos
- startLat: latitud inicial
- startLng: longitud inicial
- zoneId: zona asignar automaticamente
- idPrefix: prefijo IDs (ej: "A" para A1, A2...)

Algoritmo:
1. Calcula offsets lat/lng por spacing
2. Itera filas y columnas
3. Calcula posicion cada puesto
4. Genera ID automatico
5. Crea puesto via API
6. Muestra progreso en UI


12.3 PREVIEW CONSTRUCCION
--------------------------

showBuildPreview(pattern):
- Muestra overlay semi-transparente con preview
- Marcadores temporales indican ubicaciones
- Click confirmar para crear todos
- Click cancelar para descartar


================================================================================
13. SIDEBAR (ui/sidebar.js)
================================================================================

13.1 RENDERIZADO SIDEBAR
-------------------------

renderSidebar(spots, zones, historyData, filter, searchQuery, reservedSpotId, onSpotClick):
- Funcion principal render sidebar
- spots: array puestos
- zones: array zonas
- historyData: datos historicos por zona
- filter: filtro activo (all/free/occupied/reserved)
- searchQuery: texto busqueda
- reservedSpotId: ID puesto reservado por usuario
- onSpotClick: callback click en puesto

Comportamiento:
- Agrupa puestos por zona
- Muestra contador por zona
- Lista puestos con estado visual
- Aplica filtros y busqueda
- Preserva estado colapsado accordions


13.2 FILTROS
------------

Opciones filtro:
- all: muestra todos los puestos
- free: solo puestos libres (status=1)
- occupied: solo puestos ocupados (status=0)
- reserved: solo puestos reservados (status=2)

Implementacion:
- Chips en parte superior sidebar
- Click alterna filtro activo
- Re-render instantaneo
- Visual feedback chip seleccionado


13.3 BUSQUEDA
-------------

Funcionalidad:
- Input texto en header sidebar
- Busqueda en tiempo real (debounced 400ms)
- Busca en: ID puesto, descripcion, nombre zona
- Case-insensitive
- Muestra solo resultados coincidentes

Algoritmo:
- Usuario tipea en search input
- Sistema espera 400ms (debounce)
- Filtra spots por query
- Re-renderiza sidebar con resultados
- Si no hay resultados, muestra mensaje


13.4 ACCORDIONS ZONA
--------------------

Comportamiento:
- Cada zona es un accordion colapsable
- Click en header zona expande/colapsa
- Estado preservado al re-renderizar
- Icono chevron indica estado
- Transicion suave expand/collapse

Preservacion estado:
- Antes de re-render, guarda estado actual
- Aplica mismo estado tras re-render
- Usuario no pierde contexto al filtrar


13.5 CARDS PUESTO
-----------------

Informacion mostrada:
- ID puesto (ej: A1)
- Descripcion
- Estado visual (icono color)
- Badge estado (Libre/Ocupado/Reservado)
- Datos historicos (si disponibles)

Click en card:
- Llama callback onSpotClick(spotId)
- Dashboard hace focus en mapa
- Resalta marcador correspondiente


================================================================================
14. MODALES (ui/modals.js)
================================================================================

14.1 SISTEMA MODALES
--------------------

openModal(modalId):
- Muestra modal por ID
- Agrega clase 'active'
- Bloquea scroll body
- Focus en modal

closeModal(modalId):
- Oculta modal
- Remueve clase 'active'
- Restaura scroll body
- Limpia contenido si necesario

closeAllModals():
- Cierra todos los modales abiertos
- Util para resetear estado


14.2 MODAL DETALLE PUESTO
--------------------------

ID: modal-spot-detail

Contenido:
- ID y descripcion puesto
- Estado actual
- Zona asignada
- Boton reservar (si disponible)
- Boton cancelar reserva (si usuario tiene reserva)
- Boton editar (admin)
- Boton eliminar (admin)

Funcionalidad:
- Carga datos puesto al abrir
- Valida disponibilidad para reserva
- Maneja reserva/liberacion
- Admin puede editar/eliminar


14.3 MODAL ADMIN PUESTO
------------------------

ID: modal-admin-spot

Uso:
- Editar puesto existente
- Ver detalles tecnicos

Campos:
- ID puesto (read-only si edicion)
- Latitud
- Longitud
- Descripcion
- Zona asignada (dropdown)
- Estado sensor

Botones:
- Guardar cambios
- Cancelar
- Eliminar puesto (solo edicion)


14.4 MODAL GRAFICO EXPANDIDO
-----------------------------

ID: modal-expanded-chart

Contenido:
- Grafico ocupacion por hora (grande)
- Analisis de demanda
- Horarios pico
- Recomendaciones inteligentes
- Tendencias y patrones

Funcionalidad:
- Se abre desde dashboard
- Muestra datos ultimas 48 horas
- Permite cambiar fecha
- Exportar datos (futuro)


14.5 MODAL ZONAS
----------------

ID: modal-zones

Contenido:
- Lista completa zonas
- Puestos por zona
- Buscador zonas
- Crear nueva zona
- Editar zona existente
- Eliminar zona
- Asignar puestos a zona

Funcionalidad admin:
- CRUD completo zonas
- Reasignacion masiva puestos
- Reordenar zonas (drag & drop futuro)


================================================================================
15. GRAFICOS (ui/charts.js)
================================================================================

15.1 GRAFICO OCUPACION
-----------------------

createOccupancyChart(canvasId, data, options):
- Crea grafico lineal ocupacion vs tiempo
- Usa Chart.js
- canvasId: ID elemento canvas
- data: array valores ocupacion
- options: configuracion personalizada

Configuracion:
- Tipo: line
- Relleno bajo linea (gradient)
- Puntos suavizados (tension: 0.4)
- Grid sutil
- Tooltips personalizados
- Eje Y: 0-100%
- Eje X: labels horarios


15.2 GRAFICO SPARKLINE
-----------------------

createSparkline(canvasId, data):
- Grafico minimalista para preview
- Sin ejes, sin grid
- Solo linea y relleno
- Usado en index.html
- Datos ultimas horas


15.3 ACTUALIZACION GRAFICOS
----------------------------

updateOccupancyChart(chart, newData):
- Actualiza datos grafico existente
- No re-crea chart (mejor performance)
- Animacion suave transicion

destroyChart(canvasId):
- Destruye instancia Chart.js
- Libera memoria
- Previene memory leaks


15.4 CONFIGURACION AVANZADA
----------------------------

Plugins Chart.js usados:
- Legend: deshabilitado (no necesario)
- Title: opcional
- Tooltip: customizado con formato especial

Responsive:
- maintainAspectRatio: false
- Ajuste automatico a contenedor
- Resize listener

Colores:
- Linea: azul primary (#3b82f6)
- Relleno: gradient azul transparente
- Grid: gris claro (#e5e7eb)


================================================================================
16. TOASTS (ui/toasts.js)
================================================================================

16.1 SISTEMA NOTIFICACIONES
----------------------------

showToast(message, type, duration):
- Muestra notificacion temporal
- message: texto mostrar
- type: 'success', 'error', 'info', 'warning'
- duration: milisegundos (default 3000)

Posicion:
- Fixed bottom-right
- Stack vertical si multiples
- z-index alto para visibilidad


16.2 TIPOS TOAST
----------------

Success (verde):
- Operaciones exitosas
- Confirmaciones
- Icono: check-circle

Error (rojo):
- Errores API
- Validaciones fallidas
- Icono: exclamation-circle

Info (azul):
- Informacion general
- Tips
- Icono: info-circle

Warning (amarillo):
- Advertencias
- Acciones peligrosas
- Icono: exclamation-triangle


16.3 ANIMACIONES
----------------

Entrada:
- Slide in from right
- Fade in
- Duracion: 300ms

Salida:
- Fade out
- Slide out to right
- Duracion: 200ms

Auto-dismiss:
- Timer configurable
- Hover pausa timer
- Click cierra inmediatamente


================================================================================
17. SONIDOS (ui/sounds.js)
================================================================================

17.1 SISTEMA AUDIO
------------------

Implementacion:
- Audio sprites o archivos individuales
- Play on-demand para eventos
- Control volumen
- Soporte mute/unmute

Eventos con sonido:
- Reserva exitosa: sonido confirmacion
- Error: sonido alerta
- Notificacion: sonido suave


17.2 FUNCIONES PRINCIPALES
---------------------------

playSound(soundId):
- Reproduce sonido especifico
- soundId: identificador del audio
- Verifica si audio habilitado

toggleMute():
- Alterna entre mute/unmute
- Guarda preferencia localStorage
- Actualiza icono UI


================================================================================
18. UTILIDADES (utils/)
================================================================================

18.1 HELPERS (utils/helpers.js)
--------------------------------

debounce(func, delay):
- Retrasa ejecucion funcion
- Util para search inputs
- Evita calls excesivas
- delay: milisegundos espera

throttle(func, limit):
- Limita frecuencia ejecucion
- Util para scroll events
- limit: minimo intervalo entre calls

deepClone(obj):
- Clona objeto profundamente
- Evita referencias
- Util para inmutabilidad

generateId(prefix):
- Genera ID unico
- prefix: prefijo opcional
- Usa timestamp + random


18.2 FORMATTERS (utils/formatters.js)
--------------------------------------

formatDate(date, format):
- Formatea fecha segun patron
- date: objeto Date o string ISO
- format: patron (ej: "DD/MM/YYYY HH:mm")
- Retorna string formateado

formatRelativeTime(date):
- Tiempo relativo desde ahora
- Ej: "hace 5 minutos", "hace 2 horas"
- date: fecha comparar

formatDuration(ms):
- Convierte milisegundos a texto legible
- Ej: "1h 30m", "45 segundos"
- ms: milisegundos

formatPercentage(value, decimals):
- Formatea numero como porcentaje
- value: valor decimal (0-1) o entero (0-100)
- decimals: cantidad decimales
- Retorna string con simbolo %


18.3 VALIDATORS (utils/validators.js)
--------------------------------------

validateEmail(email):
- Valida formato email
- Regex RFC 5322 simplificado
- Retorna boolean

validateSpotId(id):
- Valida formato ID puesto
- Reglas: alfanumerico, 1-10 caracteres
- No permite caracteres especiales

validateCoordinates(lat, lng):
- Valida coordenadas geograficas
- lat: -90 a 90
- lng: -180 a 180
- Retorna boolean

validateZoneName(name):
- Valida nombre zona
- Min 2 caracteres, max 50
- No vacio
- Retorna boolean


18.4 LOGGER (utils/logger.js)
------------------------------

Sistema logging centralizado:

logger.debug(message, data):
- Logs desarrollo
- Solo en modo debug

logger.info(message, data):
- Informacion general
- Operaciones normales

logger.warn(message, data):
- Advertencias
- Situaciones anormales no criticas

logger.error(message, data):
- Errores
- Excepciones capturadas

Configuracion:
- LOG_LEVEL: control verbosidad
- ENABLE_CONSOLE: mostrar en consola
- ENABLE_REMOTE: enviar a servicio logging remoto


================================================================================
19. MAIN.JS - LOGICA PRINCIPAL
================================================================================

19.1 INICIALIZACION SISTEMA
----------------------------

Flujo DOMContentLoaded:

1. Verificar autenticacion
   - Obtener usuario actual Firebase
   - Si no autenticado, redirigir a login

2. Inicializar mapa
   - Cargar Google Maps API
   - Configurar opciones mapa
   - Centrar en ubicacion estacionamiento

3. Cargar datos iniciales
   - Fetch parking status
   - Fetch zones
   - Fetch occupancy history

4. Iniciar polling
   - Intervalo 20 segundos para status
   - Intervalo 10 minutos para historial
   - Intervalo 5 segundos para timer UI

5. Configurar listeners DOM
   - Botones filtro
   - Input busqueda
   - Modales
   - Toggle admin mode

6. Renderizar UI inicial
   - Crear marcadores mapa
   - Renderizar sidebar
   - Actualizar contadores
   - Cargar grafico


19.2 GESTION ESTADO GLOBAL
---------------------------

Objeto state:

state = {
  spots: [],              // Array puestos actuales
  zones: [],              // Array zonas
  historyData: {},        // Datos historicos
  filter: 'all',          // Filtro activo
  searchQuery: '',        // Query busqueda
  userReservation: null,  // Reserva usuario actual
  selectedSpot: null,     // Puesto seleccionado
  adminMode: false,       // Estado modo admin
  builderMode: false      // Estado modo builder
}


19.3 FUNCIONES PRINCIPALES
---------------------------

fetchData():
- Obtiene estado actual puestos
- Actualiza marcadores mapa
- Actualiza sidebar
- Actualiza contadores

updateDashboard(free, occupied, reserved):
- Actualiza contadores header
- Actualiza chart centro (donut)
- Calcula tendencia
- Muestra iconos estado

handleSpotClick(spotId):
- Callback click en puesto
- Focus mapa en ubicacion
- Resalta marcador
- Abre modal detalle (opcional)

toggleAdminMode():
- Alterna modo admin on/off
- Muestra/oculta herramientas admin
- Cambia comportamiento click mapa

openExpandedChart():
- Abre modal con grafico grande
- Carga datos historicos completos
- Genera analisis de demanda
- Calcula recomendaciones


19.4 ANALISIS DE DEMANDA
-------------------------

Metricas calculadas:

Ocupacion promedio:
- Suma valores / cantidad muestras
- Representativo del periodo

Variabilidad (CV):
- Coeficiente variacion
- (Desviacion estandar / promedio) * 100
- Indica consistencia demanda

Tiempo critico:
- Porcentaje tiempo sobre umbral (default 80%)
- Identifica saturacion frecuente

Rango ocupacion:
- Minimo y maximo del periodo
- Muestra amplitud variacion

Horarios pico:
- Detecta horas con ocupacion sostenida alta
- Identifica patrones matutinos/vespertinos


19.5 MOTOR RECOMENDACIONES
---------------------------

Sistema inteligente genera recomendaciones basado en:

Reglas implementadas:

1. Alta saturacion (tiempo critico > 30%):
   - Recomendacion: ampliar capacidad
   - Severidad: critica

2. Saturacion media (tiempo critico 10-30%):
   - Recomendacion: optimizar rotacion
   - Severidad: advertencia

3. Variabilidad alta (CV > 30%):
   - Recomendacion: implementar tarifas dinamicas
   - Severidad: advertencia

4. Baja disponibilidad promedio (< 20%):
   - Recomendacion: revisar politicas
   - Severidad: advertencia

5. Pico matutino alto (7-10h > 70%):
   - Recomendacion: priorizar reservas
   - Severidad: info

6. Pico vespertino alto (17-20h > 70%):
   - Recomendacion: aumentar rotacion
   - Severidad: info

7. Operacion normal:
   - Mensaje positivo capacidad adecuada
   - Severidad: info

Priorizacion:
- Mensajes criticos tienen prioridad
- Filtra contradicciones
- Limita a 4 recomendaciones max
- Ordena por severidad descendente


19.6 PAGE VISIBILITY API
-------------------------

Optimizacion inteligente:

Listener visibilitychange:
- Detecta cuando tab se oculta
- Pausa todos los intervalos polling
- Libera recursos

Al volver visible:
- Fetch inmediato para datos frescos
- Reanuda intervalos normalmente

Beneficio:
- Reduce requests GCP en ~80% cuando tab inactivo
- Usuario tipico: 50-80% tiempo en background
- Ahorro significativo costos operacion


19.7 SETUP INFO TOOLTIPS
-------------------------

Sistema tooltips informacion:

Comportamiento:
- Click en boton info abre tooltip
- Click mismo boton cierra tooltip
- Click fuera cierra tooltip
- ESC key cierra tooltip
- Soporte HTML en contenido

Posicionamiento:
- Arriba del boton centrado
- Ajuste automatico si fuera viewport
- Max width 260px

Contenido:
- HTML permitido (listas, negrita, etc)
- Escapado correcto en data-info attribute
- Styling con Tailwind classes


================================================================================
20. BACKEND - CLOUD RUN
================================================================================

20.1 ARQUITECTURA SERVERLESS
-----------------------------

Google Cloud Run:
- Contenedores Node.js 20
- Escalado automatico 0-N instancias
- Pay-per-use (invocaciones)
- Cold start < 1 segundo
- Memoria: 512MB - 1GB por instancia
- CPU: 1 vCPU por instancia
- Timeout: 60 segundos max


20.2 ENDPOINTS IMPLEMENTADOS
-----------------------------

GET /parking-status:
- Retorna estado actual todos los puestos
- Query Firestore collection parking_spots
- Formato respuesta JSON
- Cache control headers
- CORS habilitado

POST /create-parking-spot:
- Crea nuevo puesto
- Body: { id, lat, lng, desc, zone_id, status }
- Validacion campos requeridos
- Documento Firestore
- Retorna puesto creado

POST /update-parking-spot:
- Actualiza puesto existente
- Body: { id, ...campos_actualizar }
- Merge update Firestore
- Retorna confirmacion

POST /delete-parking-spot:
- Elimina puesto
- Body: { id }
- Delete documento Firestore
- Retorna confirmacion

GET /zones:
- Lista todas las zonas
- Query Firestore collection zones
- Ordenado por campo order
- Retorna array zonas

POST /manage-zones:
- CRUD zonas unificado
- Body: { action, ...zoneData }
- action: create/update/delete
- Maneja segun accion
- Retorna resultado

POST /reserve-spot:
- Reserva puesto para usuario
- Body: { spot_id, license_plate, duration_minutes }
- Actualiza status a 2 (reservado)
- Establece expiracion
- Retorna confirmacion

POST /release-spot:
- Libera reserva
- Body: { spot_id }
- Actualiza status a 1 (libre)
- Limpia datos reserva
- Retorna confirmacion

GET /occupancy-history:
- Datos historicos ocupacion
- Query params: days_back, zone_id
- Query collection hourly_snapshots
- Calcula agregados
- Retorna samples array

POST /ingest-parking-data:
- Endpoint para ESP32
- Body: { spot_id, sensor_status }
- Actualiza estado en tiempo real
- Timestamp automatico
- Retorna 200 OK


20.3 FIRESTORE ESTRUCTURA
--------------------------

Collection: parking_spots

Documento tipo:
{
  id: "A1",
  lat: -33.4569,
  lng: -70.6483,
  status: 1,
  desc: "Piso 1 entrada",
  zone_id: "zona-norte",
  sensor_status: 0,
  updated_at: Timestamp,
  created_at: Timestamp,
  reservation: {
    user_id: "user@email.com",
    expires_at: Timestamp,
    license_plate: "AB1234"
  }
}

Collection: zones

Documento tipo:
{
  id: "zona-norte",
  name: "Zona Norte",
  desc: "Primer piso entrada principal",
  order: 1,
  color: "#3b82f6",
  created_at: Timestamp
}

Collection: hourly_snapshots

Documento tipo:
{
  ts: Timestamp,
  global_occupancy_pct: 65.5,
  zones_summary: [
    {
      id: "zona-norte",
      name: "Zona Norte",
      occupancy_pct: 70.2,
      free: 5,
      occupied: 15,
      reserved: 0,
      total: 20
    }
  ]
}


20.4 REGLAS SEGURIDAD FIRESTORE
--------------------------------

Configuracion firestore.rules:

- Read: requiere autenticacion
- Write parking_spots: solo admin
- Write zones: solo admin
- Write hourly_snapshots: solo Cloud Run
- Delete: solo admin

Claims personalizados:
- admin: true/false en token usuario
- Valida rol en cada operacion


20.5 CLOUD SCHEDULER
---------------------

Tarea programada:
- Nombre: save-hourly-snapshot
- Frecuencia: cada 1 hora (cron: 0 * * * *)
- Target: Endpoint Cloud Run /save-hourly-snapshot
- Timezone: America/Santiago

Endpoint save-hourly-snapshot:
1. Query estado actual todos puestos
2. Calcula ocupacion global
3. Calcula ocupacion por zona
4. Crea documento en hourly_snapshots
5. Limpia snapshots antiguos (> 90 dias)


================================================================================
21. HARDWARE - ESP32 + VL53L0X
================================================================================

21.1 COMPONENTES HARDWARE
--------------------------

ESP32 DevKit v1:
- Microcontrolador dual-core 240MHz
- WiFi 802.11 b/g/n integrado
- Bluetooth (no usado)
- GPIO pins multifuncion
- ADC, PWM, I2C, SPI
- Alimentacion 5V via USB o Vin

VL53L0X ToF Sensor:
- Time-of-Flight laser ranging
- Rango medicion: 30mm - 2000mm
- Precision: +/- 3mm
- Interface: I2C
- Alimentacion: 3.3V
- Consumo: ~20mA activo

LED RGB WS2812B:
- LED direccionable individual
- Protocolo: single-wire
- Colores: RGB 256 niveles cada canal
- Voltaje: 5V
- Consumo: ~60mA blanco full


21.2 CONEXIONES ELECTRICAS
---------------------------

ESP32 <-> VL53L0X:
- SDA (GPIO 21) -> SDA
- SCL (GPIO 22) -> SCL
- 3.3V -> VCC
- GND -> GND
- XSHUT (GPIO 16) -> XSHUT (optional reset)

ESP32 <-> LED WS2812B:
- GPIO 23 -> DIN (data input)
- 5V -> VCC
- GND -> GND
- Resistor 330ohm entre GPIO y DIN
- Capacitor 1000uF entre VCC y GND


21.3 CODIGO ESP32
-----------------

Librerias usadas:
- WiFi.h: conexion WiFi
- HTTPClient.h: requests HTTP
- Adafruit_VL53L0X.h: sensor ToF
- Adafruit_NeoPixel.h: control LED RGB

Configuracion:
- SSID y password WiFi
- URL endpoint Cloud Run
- ID puesto (hardcoded por unidad)
- Umbral deteccion (mm)

Loop principal:
1. Leer distancia sensor VL53L0X
2. Determinar estado (libre/ocupado)
3. Si cambio estado:
   - Actualizar LED color
   - Enviar POST a Cloud Run
   - Log serial
4. Delay 500ms
5. Repetir

Estados LED:
- Verde: libre (distancia > umbral)
- Rojo: ocupado (distancia < umbral)
- Azul parpadeante: conectando WiFi
- Amarillo: error sensor


21.4 COMUNICACION CLOUD
------------------------

Request POST:
- URL: https://cloud-run-url.run.app/ingest-parking-data
- Headers: Content-Type: application/json
- Body: { "spot_id": "A1", "sensor_status": 0 }
- Timeout: 10 segundos
- Retry: 3 intentos con backoff

Respuesta esperada:
- Status: 200 OK
- Body: { "success": true }

Manejo errores:
- WiFi desconectado: reintentar conexion
- HTTP error: log y continuar (no bloquear)
- Sensor error: LED amarillo, reiniciar sensor


21.5 CALIBRACION SENSOR
------------------------

Proceso calibracion:
1. Medir distancia suelo a sensor instalado
2. Medir altura vehiculo tipico
3. Establecer umbral = (distancia_suelo + distancia_vehiculo) / 2
4. Agregar margen error (+/- 50mm)
5. Probar con vehiculos reales
6. Ajustar umbral si necesario

Consideraciones:
- Luz ambiental: no afecta (laser infrarrojo)
- Superficies reflectivas: pueden causar lecturas erraticas
- Angulo instalacion: perpendicular al suelo ideal
- Distancia maxima efectiva: 1.5 metros recomendado


21.6 INSTALACION FISICA
------------------------

Ubicacion sensor:
- Techo sobre centro del puesto
- Altura 2-3 metros
- Apuntando directamente hacia abajo
- Protegido de agua/polvo (carcasa)

Alimentacion:
- Fuente 5V 2A minimo
- Cable calibre 20 AWG
- Distancia maxima 10 metros
- Considerar caida tension

Montaje:
- Soporte ajustable angulo
- Fijacion segura (no vibrar)
- Cable management ordenado
- Señalizacion unidad (ID puesto)


================================================================================
22. OPTIMIZACIONES RENDIMIENTO
================================================================================

22.1 CACHE INTELIGENTE
-----------------------

Implementacion multi-capa:

Memoria navegador:
- Estado puestos: 15 segundos TTL
- Zonas: 5 minutos TTL
- Historial: 10 minutos TTL

localStorage:
- Fallback sin conexion
- Persiste entre sesiones
- No expira (manual refresh)

Cache invalidation:
- Automatica tras operaciones escritura
- Manual via boton refresh
- Timestamp para validacion


22.2 POLLING ADAPTATIVO
------------------------

Intervalos configurables:

Estado puestos:
- Activo: 20 segundos
- Background: pausado (Visibility API)

Historial:
- Activo: 10 minutos
- Background: pausado

Timer UI:
- Siempre: 5 segundos (solo local)

Beneficios:
- Reduce requests GCP 70-85%
- Mantiene UX responsiva
- Ajustable segun necesidad


22.3 DEBOUNCE Y THROTTLE
-------------------------

Busqueda:
- Debounce 400ms
- Evita queries mientras usuario tipea
- Reduce renders innecesarios

Scroll events:
- Throttle 100ms
- Limita frecuencia actualizacion
- Mejora performance dispositivos lentos

Resize events:
- Throttle 200ms
- Ajuste mapa y graficos
- No bloquea UI


22.4 LAZY RENDERING
-------------------

Sidebar puestos:
- Render solo puestos visibles
- Virtual scrolling futuro
- Intersection Observer

Graficos:
- Carga bajo demanda
- Destruye al cerrar modal
- Reutiliza instancias cuando posible


22.5 OPTIMIZACION IMAGENES
---------------------------

No aplica directamente (sin imagenes pesadas)

Consideraciones:
- Iconos via Font Awesome (CDN)
- Sin background images
- SVG para logos (escalable)


22.6 CODE SPLITTING
-------------------

Modulos JavaScript:
- Carga bajo demanda
- Import dinamico (futuro)
- Reduce bundle inicial

Actualmente:
- Todos los modulos cargados al inicio
- Consideracion futura: lazy load admin modules


================================================================================
23. DESPLIEGUE FIREBASE
================================================================================

23.1 CONFIGURACION FIREBASE
----------------------------

firebase.json:
{
  "hosting": {
    "public": ".",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**",
      "gcp-functions/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ],
    "headers": [
      {
        "source": "**/*.@(js|css)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "max-age=31536000"
          }
        ]
      }
    ]
  }
}

.firebaserc:
{
  "projects": {
    "default": "proyecto-id-gcp"
  }
}


23.2 COMANDOS DESPLIEGUE
-------------------------

Instalar Firebase CLI:
$ npm install -g firebase-tools

Login Firebase:
$ firebase login

Inicializar proyecto:
$ firebase init hosting

Desplegar:
$ firebase deploy --only hosting

Preview cambios:
$ firebase hosting:channel:deploy preview


23.3 HOSTING FIREBASE
---------------------

Caracteristicas:
- CDN global
- SSL automatico
- HTTP/2
- Gzip automatico
- Cache control headers
- Dominios custom

URL produccion:
- https://proyecto-id.web.app
- https://proyecto-id.firebaseapp.com


23.4 CLOUD RUN DESPLIEGUE
--------------------------

Crear imagen Docker:
$ gcloud builds submit --tag gcr.io/proyecto-id/funcion-nombre

Desplegar Cloud Run:
$ gcloud run deploy funcion-nombre \
  --image gcr.io/proyecto-id/funcion-nombre \
  --platform managed \
  --region us-central1 \
  --allow-unauthenticated \
  --memory 512Mi

Actualizar:
$ gcloud run deploy funcion-nombre \
  --image gcr.io/proyecto-id/funcion-nombre:latest


23.5 VARIABLES ENTORNO
-----------------------

Cloud Run:
- FIRESTORE_PROJECT_ID
- ADMIN_EMAIL
- SECRET_KEY

Frontend:
- CONFIG.js contiene todas las claves
- API keys expuestas (OK para frontend)
- Restricciones por dominio en GCP Console


================================================================================
24. MONITOREO Y LOGS
================================================================================

24.1 CLOUD LOGGING
------------------

Logs disponibles:
- Cloud Run requests
- Firestore operations
- Authentication events
- Cloud Scheduler jobs

Filtros utiles:
- resource.type="cloud_run_revision"
- severity >= ERROR
- timestamp >= "2025-12-01"


24.2 CLOUD MONITORING
---------------------

Metricas clave:
- Request count
- Request latency
- Error rate
- Instance count
- CPU utilization
- Memory utilization

Alertas configuradas:
- Error rate > 5%
- Latency p99 > 1000ms
- Instance count > 10


24.3 ANALYTICS FRONTEND
-----------------------

No implementado actualmente

Consideraciones futuras:
- Google Analytics 4
- Custom events (reservas, clicks)
- User flows
- Performance metrics


================================================================================
25. SEGURIDAD
================================================================================

25.1 AUTENTICACION
------------------

Firebase Authentication:
- Email/Password habilitado
- Email verification opcional
- Password recovery
- Session management

Tokens:
- JWT tokens automaticos
- Refresh tokens
- Expiracion 1 hora
- Renovacion automatica


25.2 AUTORIZACION
-----------------

Roles:
- Usuario regular: read, reservar
- Administrador: CRUD completo

Implementacion:
- Custom claims en token
- Validacion backend
- UI adapta segun rol


25.3 FIRESTORE RULES
--------------------

Reglas actuales:

match /parking_spots/{spotId} {
  allow read: if request.auth != null;
  allow write: if request.auth.token.admin == true;
}

match /zones/{zoneId} {
  allow read: if request.auth != null;
  allow write: if request.auth.token.admin == true;
}

match /hourly_snapshots/{snapshotId} {
  allow read: if request.auth != null;
  allow write: if false; // Solo Cloud Functions
}


25.4 API SECURITY
-----------------

Cloud Run:
- CORS configurado
- Rate limiting (Cloud Armor futuro)
- Input validation
- SQL injection: N/A (NoSQL)
- XSS: sanitizacion outputs

Best practices:
- HTTPS obligatorio
- Headers seguridad (CSP, X-Frame-Options)
- Secrets en Secret Manager
- No hardcodear credenciales


25.5 FRONTEND SECURITY
----------------------

Protecciones:
- No localStorage para tokens sensibles (Firebase maneja)
- Sanitizacion HTML en tooltips
- Validacion inputs cliente y servidor
- CSRF: tokens Firebase

Vulnerabilidades mitigadas:
- XSS: escape HTML
- CSRF: SameSite cookies
- Clickjacking: X-Frame-Options
- MITM: HTTPS obligatorio


================================================================================
26. TESTING
================================================================================

26.1 TESTING MANUAL
-------------------

Checklist funcional:

Dashboard:
- [ ] Login exitoso
- [ ] Logout exitoso
- [ ] Mapa carga correctamente
- [ ] Marcadores aparecen
- [ ] Click marcador funciona
- [ ] Sidebar renderiza
- [ ] Filtros funcionan
- [ ] Busqueda funciona
- [ ] Modal detalle abre
- [ ] Reserva exitosa
- [ ] Cancelar reserva funciona

Admin:
- [ ] Toggle admin mode
- [ ] Crear puesto
- [ ] Editar puesto
- [ ] Eliminar puesto
- [ ] Crear zona
- [ ] Editar zona
- [ ] Eliminar zona
- [ ] Asignar puestos zona


26.2 TESTING AUTOMATIZADO
--------------------------

No implementado actualmente

Frameworks recomendados:
- Jest: unit tests
- Cypress: E2E tests
- Playwright: cross-browser

Casos criticos test:
- Autenticacion flows
- Reserva/liberacion puestos
- CRUD admin operations
- Cache invalidation
- Error handling


26.3 TESTING PERFORMANCE
-------------------------

Herramientas:
- Lighthouse (Chrome DevTools)
- WebPageTest
- GTmetrix

Metricas objetivo:
- FCP < 1.5s
- LCP < 2.5s
- TTI < 3.5s
- CLS < 0.1
- FID < 100ms


================================================================================
27. COSTOS OPERACION
================================================================================

27.1 MODELO PRICING GCP
-----------------------

Cloud Run:
- Invocaciones: $0.40 por millon
- CPU: $0.00002400 por vCPU-segundo
- Memoria: $0.00000250 por GB-segundo
- Free tier: 2 millones invocaciones/mes

Firestore:
- Lecturas: $0.06 por 100k
- Escrituras: $0.18 por 100k
- Eliminaciones: $0.02 por 100k
- Almacenamiento: $0.18 por GB-mes
- Free tier: 50k lecturas, 20k escrituras diarias

Firebase Hosting:
- Almacenamiento: $0.026 por GB
- Transfer: $0.15 por GB
- Free tier: 10GB almacenamiento, 360MB transfer diarios


27.2 ESTIMACIONES COSTO
------------------------

Escenario pequeño (20-50 puestos):
- Requests diarios: 4500-12000
- Costo estimado: $6-18/mes

Escenario medio (100-300 puestos):
- Requests diarios: 21000-63000
- Costo estimado: $27-75/mes

Escenario grande (500-1000 puestos):
- Requests diarios: 105000-210000
- Costo estimado: $105-270/mes

Nota: Con optimizaciones implementadas


27.3 OPTIMIZACION COSTOS
-------------------------

Estrategias implementadas:
- Cache agresivo (reduce lecturas 60-75%)
- Polling inteligente (reduce requests 70-85%)
- Page Visibility API (pausa en background)
- Intervalos configurables

Estrategias futuras:
- WebSockets para updates en tiempo real
- Compression headers
- CDN caching mas agresivo
- Batch operations


================================================================================
28. ROADMAP FUTURO
================================================================================

28.1 FUNCIONALIDADES PENDIENTES
--------------------------------

Corto plazo (1-3 meses):
- Sistema notificaciones push
- Exportar datos CSV/PDF
- Reportes personalizados
- Dashboard mobile app
- Modo oscuro UI

Mediano plazo (3-6 meses):
- Integracion pagos (reservas pagas)
- API publica para terceros
- Webhooks eventos
- Machine learning prediccion demanda
- Gestion multiple estacionamientos

Largo plazo (6-12 meses):
- App movil nativa (Flutter)
- IoT gateway intermedio
- Edge computing en ESP32
- Blockchain para auditoria
- IA generativa asistente


28.2 MEJORAS TECNICAS
---------------------

Performance:
- Service Workers para offline
- IndexedDB para datos grandes
- WebAssembly para calculos pesados
- HTTP/3 QUIC

Arquitectura:
- Microservicios adicionales
- Message queue (Pub/Sub)
- GraphQL API
- Real-time con Socket.io


28.3 HARDWARE V2
----------------

Mejoras sensor:
- Camara vision computacional
- Deteccion matricula OCR
- Sensores movimiento PIR
- Comunicacion LoRaWAN


================================================================================
29. TROUBLESHOOTING
================================================================================

29.1 PROBLEMAS COMUNES
----------------------

Mapa no carga:
- Verificar API key valida
- Revisar restricciones dominio
- Check console errors
- Firewall bloqueando?

Marcadores no aparecen:
- Datos spots vacios?
- Coordenadas validas?
- Google Maps inicializado?
- Check network requests

Polling no funciona:
- Tab en background? (esperado)
- Errores API? Check logs
- CORS? Verificar headers
- Timeout? Aumentar limite

Reserva falla:
- Usuario autenticado?
- Puesto disponible?
- Expiracion valida?
- Firestore rules OK?


29.2 DEBUGGING
--------------

Herramientas:
- Chrome DevTools
- React DevTools (N/A)
- Network tab
- Console logs
- Firebase Debugger

Logger.js:
- Habilitar modo debug
- Ver logs filtrados
- Exportar logs archivo


29.3 SOPORTE
------------

Contactos:
- Email: soporte@sparking.com
- Slack: canal #sparking-support
- Documentacion: docs.sparking.com


================================================================================
30. CREDITOS Y LICENCIA
================================================================================

30.1 TECNOLOGIAS UTILIZADAS
----------------------------

Frontend:
- Tailwind CSS
- Google Maps JavaScript API
- Chart.js
- Font Awesome
- Firebase SDK

Backend:
- Node.js
- Express.js (implicito Cloud Run)
- Firebase Admin SDK
- Google Cloud Platform

Hardware:
- Arduino ecosystem
- Adafruit libraries
- ESP32 core


30.2 LICENCIA
-------------

Codigo propietario S-Parking
Copyright 2025 S-Parking Team
Todos los derechos reservados

Licencias third-party:
- Ver package.json dependencies
- Respetar terminos cada libreria


30.3 CONTRIBUIDORES
-------------------

Desarrollo:
- Equipo S-Parking

Agradecimientos:
- Comunidad Arduino
- Stack Overflow
- Google Cloud documentation
- Firebase community


================================================================================
FIN DOCUMENTACION TECNICA COMPLETA
================================================================================

NOTA IMPORTANTE:
Este documento refleja el estado actual del proyecto S-Parking a diciembre 2025.
Todas las funcionalidades descritas estan implementadas y operativas.
Para actualizaciones, consultar repositorio o contactar equipo desarrollo.

FECHA ULTIMA ACTUALIZACION: 02/12/2025
